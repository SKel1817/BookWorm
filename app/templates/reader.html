{% extends 'base.html' %}

{% block title %}{{ title }} | BookWorm Reader{% endblock %}

{% block content %}
<div class="max-w-5xl mx-auto flex space-x-4">
    <!-- Reader Content as iframe-like container -->
    <div id="reader-container" class="docs-container flex-1">
        <div id="reader-content" class="docs-content">
            {{ content|safe }}
        </div>
    </div>

    <!-- New Sidebar for Annotations -->
    <div id="annotation-panel"
        class="w-64 p-4 light:bg-gray-50 bg-opacity-50 rounded-lg overflow-auto hidden"></div>
    <!-- We'll append annotation boxes here via JavaScript -->
</div>
</div>
<!-- Cookie consent bar -->
<div id="cookie-consent"
    class="fixed bottom-0 left-0 w-full bg-primary-100 dark:bg-primary-800 p-4 flex justify-between items-center shadow-lg z-50 hidden">
    <div class="text-sm">
        We use cookies to save your Focus Garden progress. This helps your plants grow across reading sessions.
    </div>
    <div class="flex space-x-2">
        <button id="deny-cookies"
            class="px-3 py-1 bg-white dark:bg-gray-700 text-primary-800 dark:text-primary-200 rounded text-sm">
            No thanks
        </button>
        <button id="accept-cookies" class="px-3 py-1 bg-accent-600 dark:bg-accent-500 text-white rounded text-sm">
            Accept
        </button>
    </div>
</div>
</div>
{% endblock %}

{% block footer %}
<!-- Focus Mode Garden (moved to footer) -->
<footer class="mt-12 pt-6">
    <div id="focus-garden">
        <h3 class="text-center text-lg font-medium mb-4 text-accent-600 dark:text-accent-400">
            <i class="fas fa-seedling mr-2"></i>Your Focus Garden
        </h3>
        <div class="flex justify-between items-center mt-2 text-sm">
            <div>
                <span id="focus-time">0</span> minutes of distraction-free reading
            </div>
            <div class="text-right">
                <span class="text-red-500 hidden" id="focus-draining">‚ö†Ô∏è Focus draining...</span>
            </div>
        </div>
        <div class="mt-2 w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
            <div id="focus-progress" class="bg-accent-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>

        <!-- Mobile: h-64, Desktop: 16:9 ratio (needs aspect-ratio plugin or Tailwind 3) -->
        <div
        class="h-64 w-full bg-day-mode dark:bg-night-mode bg-cover bg-center rounded-lg overflow-hidden relative"
        style="background-size: contain; background-position: center; background-repeat: no-repeat;">
        <div class="flex justify-center items-end h-full">
            <div id="garden-elements" class="flex space-x-2 mb-2"></div>
        </div>
        <div class="absolute bottom-0 left-0 right-0 h-4 bg-accent-800 dark:bg-accent-900 opacity-30"></div>
    </div>
    
</footer>

{% endblock %}

{% block head %}
<style>
    /* Google Docs like styling */
    .docs-container {
        background-color: #F9F9F9;
        padding: 0;
        min-height: 70vh;
        overflow-y: auto;
        border: 1px solid #E0E0E0;
    }

    .dark .docs-container {
        background-color: #2D2D2D;
        border-color: #444444;
    }

    .docs-content {
        background-color: white;
        max-width: 850px;
        margin: 40px auto;
        padding: 60px;
        min-height: 1100px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        font-family: 'Arial', sans-serif;
        color: #333;
        line-height: 1.6;
        font-size: 14px;
    }

    .dark .docs-content {
        background-color: #333333;
        color: #E0E0E0;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .docs-content h1,
    .docs-content h2,
    .docs-content h3 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        font-weight: 400;
    }

    .docs-content h1 {
        font-size: 2em;
    }

    .docs-content h2 {
        font-size: 1.5em;
    }

    .docs-content p {
        margin-bottom: 1em;
    }

    .docs-content a {
        color: #1a73e8;
        text-decoration: none;
    }

    .dark .docs-content a {
        color: #8ab4f8;
    }

    .docs-content img {
        max-width: 100%;
        height: auto;
        margin: 1em 0;
    }

    .annotation-box {
        background-color: #fff;
        border: 1px solid #ccc;
        margin-bottom: 1rem;
        padding: 0.5rem;
        border-radius: 4px;
    }


    .annotation-box textarea {
        width: 100%;
        height: 60px;
        resize: vertical;
        margin-bottom: 5px;
    }

    .annotation-actions {
        text-align: right;
    }

    .annotation-actions button {
        margin-left: 5px;
        font-size: 0.85rem;
        padding: 3px 6px;
    }

    /* Garden plant animations */
    @keyframes growPlant {
        0% {
            transform: scale(0.5);
            opacity: 0.5;
        }

        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .garden-plant {
        animation: growPlant 1s ease-out forwards;
    }

    /* Focus draining animation */
    @keyframes pulse {
        0% {
            opacity: 0.7;
        }

        50% {
            opacity: 1;
        }

        100% {
            opacity: 0.7;
        }
    }

    #focus-draining {
        animation: pulse 2s infinite;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    let evilModeActive = JSON.parse(localStorage.getItem('evilModeActive')) || false;

    document.addEventListener('DOMContentLoaded', function () {
        // ------------------------------
        // ELEMENT REFERENCES & INITIAL STATE
        // ------------------------------
        const originalTitle = document.title;
        const readerContent = document.getElementById('reader-content');
        const fontDecrease = document.getElementById('font-decrease');
        const fontIncrease = document.getElementById('font-increase');
        const fontFamily = document.getElementById('font-family');
        const spacingDecrease = document.getElementById('spacing-decrease');
        const spacingIncrease = document.getElementById('spacing-increase');
        const annotationMode = document.getElementById('annotation-mode');
        const readAloud = document.getElementById('read-aloud');
        const cookieConsent = document.getElementById('cookie-consent');
        const acceptCookies = document.getElementById('accept-cookies');
        const denyCookies = document.getElementById('deny-cookies');
        const focusDraining = document.getElementById('focus-draining');
        const focusProgress = document.getElementById('focus-progress');
        const focusTimeDisplay = document.getElementById('focus-time');
        const gardenElements = document.getElementById('garden-elements');
        const fontColorDropdown = document.getElementById('font-color');
        const annotationToggle = document.getElementById('annotation-toggle');
        const url = '{{ url }}';

        // Load saved articles from localStorage
        const savedArticles = JSON.parse(localStorage.getItem('savedArticles')) || [];
        const articlePreferences = savedArticles.find(article => article.url === url) || {};
        if (articlePreferences.fontSize) {
            readerContent.style.fontSize = articlePreferences.fontSize;
        }
        if (articlePreferences.fontFamily) {
            readerContent.style.fontFamily = articlePreferences.fontFamily;
            fontFamily.value = articlePreferences.fontFamily;
        }
        if (articlePreferences.fontColor) {
            readerContent.style.color = articlePreferences.fontColor;
            fontColorDropdown.value = articlePreferences.fontColor;
        }
        if (articlePreferences.lineHeight) {
            readerContent.style.lineHeight = articlePreferences.lineHeight;
        }
        if (articlePreferences.highlights) {
            readerContent.innerHTML = articlePreferences.highlights;
        }
        if (articlePreferences.annotations) {
            articlePreferences.annotations.forEach(annotation => {
                addAnnotation(annotation.text, annotation.note);
            });
        }

        const toolbarButtons = document.querySelectorAll(
            '#font-decrease, #font-increase, #read-aloud, #spacing-decrease, #spacing-increase, #highlight-toggle, #eraser-toggle, #chat-toggle, #magic-highlight'
        );
        const originalToolbarHTML = {};
        toolbarButtons.forEach(btn => {
            originalToolbarHTML[btn.id] = btn.innerHTML;
        });
        const fontFamilySelect = document.getElementById('font-family');
        const originalFontFamilyOptions = fontFamilySelect ? fontFamilySelect.innerHTML : '';

        function activateEvilMode() {
            // Replace toolbar buttons' content with an evil emoji
            toolbarButtons.forEach(btn => {
                const evilEmojis = ['üòà', 'üëπ', 'üë∫', 'üíÄ', 'üëª', 'üëΩ', 'ü§ñ', 'üëæ'];
                const randomEmoji = evilEmojis[Math.floor(Math.random() * evilEmojis.length)];
                btn.innerHTML = randomEmoji;
            });
            // Change the font-family dropdown to evil choices
            if (fontFamilySelect) {
                fontFamilySelect.innerHTML = `<option value="wingdings">Wingdings</option>`;
            }
            // Change the reader content to use a less readable font (e.g. Wingdings)
            if (readerContent) {
                readerContent.style.fontFamily = 'Wingdings, sans-serif';
                readerContent.style.fontFace = `
                    @font-face {
                        font-family: 'Wingdings';
                        src: url('/static/webfonts/Wingdings.ttf') format('truetype');
                    }
                `;
            }
            // Additional evil modifications can be added here
        }

        function deactivateEvilMode() {
            // Restore original toolbar buttons
            toolbarButtons.forEach(btn => {
                if (originalToolbarHTML[btn.id]) {
                    btn.innerHTML = originalToolbarHTML[btn.id];
                }
            });
            // Restore original font-family dropdown options
            if (fontFamilySelect) {
                fontFamilySelect.innerHTML = originalFontFamilyOptions;
            }
            // Restore the reader content font
            if (readerContent) {
                readerContent.style.fontFamily = '';
            }
            // Additional restoration code can be added here
        }

        // Load evil mode state from localStorage
        if (evilModeActive) {
            activateEvilMode();
        }

        // Save preferences to localStorage
        function savePreferences() {
            const preferences = {
                url: url,
                title: '{{ title }}',
                fontSize: readerContent.style.fontSize,
                fontFamily: readerContent.style.fontFamily,
                fontColor: readerContent.style.color,
                lineHeight: readerContent.style.lineHeight,
                highlights: readerContent.innerHTML,
                annotations: getAnnotations()
            };
            const index = savedArticles.findIndex(article => article.url === url);
            if (index !== -1) {
                savedArticles[index] = preferences;
            } else {
                savedArticles.push(preferences);
            }
            localStorage.setItem('savedArticles', JSON.stringify(savedArticles));
            localStorage.setItem('evilModeActive', JSON.stringify(evilModeActive));
        }


        let currentFontSize = parseInt(window.getComputedStyle(readerContent).fontSize);
        let currentLineHeight = 1.6;
        let isAnnotationMode = false;
        let isReading = false;
        let speechUtterance = null;
        let cookiesAccepted = false;

        // Focus mode variables
        let focusModeActive = true; // Set true to start focus mode automatically
        let focusMinutes = 0;
        let focusTimer = null;
        let drainTimer = null;
        let elapsedSeconds = 0; // Track seconds within the current minute
        const evilModeToggle = document.getElementById('evil-mode-toggle');
        const COOKIE_CONSENT_NAME = 'bookworm_cookie_consent';
        const FOCUS_MINUTES_NAME = 'bookworm_focus_minutes';
        const GARDEN_PLANTS_NAME = 'bookworm_garden_plants';
        const PLANTS_PER_MINUTE = 1; // 1 plant per minute

        // ------------------------------
        // HELPER FUNCTIONS
        // ------------------------------
        // Reverse a string (for evil read-aloud)
        function reverseText(text) {
            return text.split('').reverse().join('');
        }

        // ------------------------------
        // COOKIE FUNCTIONS & DATA LOADING
        // ------------------------------
        function checkCookieConsent() {
            const consent = getCookie(COOKIE_CONSENT_NAME);
            // If accepted, we can store data. If denied, we hide banner but do not store data.
            if (consent === 'accepted') {
                cookiesAccepted = true;
            } else if (consent === 'denied') {
                cookiesAccepted = false;
            } else {
                cookieConsent.classList.remove('hidden');
            }
        }

        function setCookie(name, value, days) {
            // Only set other cookies if user has accepted or if this is the consent cookie
            if (!cookiesAccepted && name !== COOKIE_CONSENT_NAME) return;
            let expires = '';
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = '; expires=' + date.toUTCString();
            }
            document.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/';
        }

        function getCookie(name) {
            const nameEQ = name + '=';
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i].trim();
                if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length));
            }
            return null;
        }

        function loadFocusData() {
            const savedMinutes = getCookie(FOCUS_MINUTES_NAME);
            if (savedMinutes) {
                focusMinutes = parseInt(savedMinutes);
                focusTimeDisplay.textContent = focusMinutes;
                updateProgressBar(0);
            }
            const savedPlants = getCookie(GARDEN_PLANTS_NAME);
            if (savedPlants) {
                try {
                    const plants = JSON.parse(savedPlants);
                    plants.forEach(plant => {
                        console.log("Loading previous garden element:", plant);
                        addGardenElement(plant.image, plant.height);
                    });
                } catch (e) {
                    console.error('Failed to parse garden plants cookie', e);
                }
            }
        }

        function saveFocusData() {
            if (cookiesAccepted) {
                setCookie(FOCUS_MINUTES_NAME, focusMinutes.toString(), 365);
                const plants = [];
                document.querySelectorAll('.garden-plant').forEach(plant => {
                    const img = plant.querySelector('img');
                    if (img) {
                        plants.push({
                            image: img.getAttribute('src').replace('/static/images/', ''),
                            height: img.style.height
                        });
                    }
                });
                setCookie(GARDEN_PLANTS_NAME, JSON.stringify(plants), 365);
            }
        }

        // Cookie Consent Buttons
        acceptCookies.addEventListener('click', function () {
            setCookie(COOKIE_CONSENT_NAME, 'accepted', 365);
            cookiesAccepted = true;
            cookieConsent.classList.add('hidden');
            // Now that user accepted, we can load or save data
            loadFocusData();
        });

        denyCookies.addEventListener('click', function () {
            setCookie(COOKIE_CONSENT_NAME, 'denied', 365);
            cookiesAccepted = false;
            cookieConsent.classList.add('hidden');
        });

        checkCookieConsent();
        if (cookiesAccepted) {
            loadFocusData();
        }

        // ------------------------------
        // EVIL MODE TOGGLE & MODIFICATIONS
        // ------------------------------
        evilModeToggle.addEventListener('click', function () {
            evilModeActive = !evilModeActive;
            if (evilModeActive) {
                activateEvilMode();
            } else {
                deactivateEvilMode();
            }
            localStorage.setItem('evilModeActive', JSON.stringify(evilModeActive));
        });

        // ------------------------------
        // FOCUS MODE FUNCTIONS
        // ------------------------------
        function startFocusMode() {
            console.log("DEBUG: Starting focus mode, current focus minutes:", focusMinutes);
            elapsedSeconds = 0;
            focusTimer = setInterval(() => {
                elapsedSeconds++;
                updateProgressBar(elapsedSeconds);
                if (elapsedSeconds >= 60) {
                    focusMinutes++;
                    elapsedSeconds = 0;
                    focusTimeDisplay.textContent = focusMinutes;
                    console.log("DEBUG: Focus minute incremented to:", focusMinutes);
                    addRandomGardenElement();
                    saveFocusData();
                }
            }, 1000);
            const expectedPlants = Math.floor(focusMinutes * PLANTS_PER_MINUTE);
            const currentPlants = document.querySelectorAll('.garden-plant').length;
            if (currentPlants < expectedPlants) {
                addRandomGardenElement();
            }
        }

        function updateProgressBar(seconds) {
            const progress = (seconds / 60) * 100;
            focusProgress.style.width = `${progress}%`;
        }

        function addRandomGardenElement() {
            console.log("DEBUG: Adding random garden element.");
            const plantTypes = [{
                    image: 'Orange_Flower.png',
                    height: '100px'
                },
                {
                    image: 'Red_Flower.png',
                    height: '100px'
                },
                {
                    image: 'Capybara.png',
                    height: '100px'
                },
                {
                    image: 'Duck.png',
                    height: '100px'
                },
                {
                    image: 'Worm.gif',
                    height: '100px'
                },
                {
                    image: 'Yellow_Flower.png',
                    height: '100px'
                },
                {
                    image: 'Purple_Flower.png',
                    height: '100px'
                },
                {
                    image: 'Blue_Flower.png',
                    height: '100px'
                }

            ];
            const randomPlant = plantTypes[Math.floor(Math.random() * plantTypes.length)];
            console.log("DEBUG: Random plant selected:", randomPlant);
            addGardenElement(randomPlant.image, randomPlant.height);
        }

        function addGardenElement(image, height) {
            const element = document.createElement('div');
            element.className = 'garden-plant';
            element.style.position = 'absolute';

            const containerBox = gardenElements.closest('.relative');
            if (containerBox) {
                const containerWidth = containerBox.offsetWidth;
                const containerHeight = containerBox.offsetHeight;

                // We'll assume the hill is roughly in the bottom 60% of the image
                const hillStartY = containerHeight * 0.4;

                let randomTop;
                let randomLeft;
                let overlap;
                do {
                    randomTop = hillStartY + Math.random() * ((containerHeight - 60) - hillStartY);
                    randomLeft = Math.random() * (containerWidth - 40);

                    overlap = Array.from(gardenElements.children).some(existingElement => {
                        const existingRect = existingElement.getBoundingClientRect();
                        const newRect = {
                            left: randomLeft,
                            top: randomTop,
                            right: randomLeft + 40,
                            bottom: randomTop + 40
                        };
                        return !(
                            newRect.right < existingRect.left ||
                            newRect.left > existingRect.right ||
                            newRect.bottom < existingRect.top ||
                            newRect.top > existingRect.bottom
                        );
                    });
                } while (overlap);

                element.style.left = randomLeft + 'px';
                element.style.top = randomTop + 'px';
            }
            element.innerHTML = `<img src="/static/images/${image}" style="height: ${height};" alt="Flower" />`;
            gardenElements.appendChild(element);
        }

        function startFocusDraining() {
            console.log("DEBUG: Starting focus draining.");
            clearInterval(focusTimer);
            focusTimer = null;
            focusDraining.classList.remove('hidden');
            document.title = '‚ö†Ô∏è Focus Draining';
            drainTimer = setInterval(() => {
                console.log("DEBUG: Draining focus minute. Current focus minutes:", focusMinutes);
                if (focusMinutes > 0) {
                    focusMinutes--;
                    focusTimeDisplay.textContent = focusMinutes;
                    updateProgressBar(0);
                    saveFocusData();
                    if (gardenElements.children.length > 0) {
                        console.log("DEBUG: Removing a garden element due to focus drain.");
                        gardenElements.removeChild(gardenElements.lastChild);
                    }
                }
            }, 30000);
        }

        function stopFocusDraining() {
            console.log("DEBUG: Stopping focus draining.");
            clearInterval(drainTimer);
            drainTimer = null;
            focusDraining.classList.add('hidden');
            document.title = originalTitle;
        }
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                if (focusModeActive) {
                    startFocusDraining();
                }
            } else {
                stopFocusDraining();
                if (focusModeActive && !focusTimer) {
                    startFocusMode();
                }
            }
        });

        // ------------------------------
        // OTHER FUNCTIONALITY (Read Aloud, Font/Spacing, Annotation)
        // ------------------------------
        readAloud.addEventListener('click', () => {
            if (!isReading) {
                isReading = true;
                readAloud.classList.add('bg-accent-200', 'dark:bg-accent-800');
                const originalText = readerContent.innerText;
                // If evil mode is active, reverse the text before speaking and lower the pitch
                const textToSpeak = evilModeActive ? reverseText(originalText) : originalText;
                speechUtterance = new SpeechSynthesisUtterance(textToSpeak);
                if (evilModeActive) {
                    speechUtterance.pitch = 0.1; // Lower the pitch for evil mode
                    speechUtterance.rate = 1.2; // Increase the rate for evil mode
                }
                speechUtterance.onend = () => {
                    isReading = false;
                    readAloud.classList.remove('bg-accent-200', 'dark:bg-accent-800');
                };
                speechSynthesis.speak(speechUtterance);
            } else {
                isReading = false;
                readAloud.classList.remove('bg-accent-200', 'dark:bg-accent-800');
                speechSynthesis.cancel();
            }
        });

        window.highlightText = function (text) {
            console.log('Highlighting text:', text);
            const content = readerContent.innerHTML;
            const highlightedContent = content.replace(new RegExp(text, 'gi'), match =>
                `<span class="bg-yellow-300">${match}</span>`);
            readerContent.innerHTML = highlightedContent;
            savePreferences();
        }

        window.removeHighlight = function (text) {
            console.log('Removing highlight for text:', text);
            const content = readerContent.innerHTML;
            const unhighlightedContent = content.replace(/<span class="bg-yellow-300">(.*?)<\/span>/gi, (
                match, p1) => {
                return p1.includes(text) ? p1 : match;
            });
            readerContent.innerHTML = unhighlightedContent;
            savePreferences();
        }

        const magicHighlight = document.getElementById('magic-highlight');
        const loadingScreen = document.getElementById('loading-screen');

        magicHighlight.addEventListener('click', function () {
            loadingScreen.style.display = 'flex';
            const content = document.getElementById('reader-content').innerText;

            fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `You are a text summarization agent, which has the capability to highlight important aspects or key points of an article below. For all of the text in the article, please respond with a highlight(text) function, stating the exact text that you want highlighted. Separate these functions by semicolons, and ONLY respond with the function calls and nothing else. Feel free to highlight more often, but in shorter segments, as this will help the user. Make the text to highlight EXACTLY what is listed in the article, otherwise the system will not highlight for you. Here is the article: ${content}`
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log(data);
                    if (data.success) {
                        const highlights = data.response.match(/highlight\((.*?)\);/g);
                        if (highlights) {
                            highlights.forEach(call => {
                                const textToHighlight = call.match(/highlight\((.*?)\);/)[
                                    1];
                                highlightText(textToHighlight.replace(/['"]/g, ''));
                            });
                        }
                    } else {
                        showToast('Error: ' + data.error);
                    }
                })
                .catch(error => {
                    showToast('Error: ' + error.message);
                })
                .finally(() => {
                    loadingScreen.style.display = 'none';
                });
        });

        fontDecrease.addEventListener('click', () => {
            if (currentFontSize > 12) {
                currentFontSize -= 1;
                readerContent.style.fontSize = currentFontSize + 'px';
                savePreferences();
            }
            if (evilModeActive === true) {
                readerContent.style.fontSize = '1px';
            }
        });
        fontIncrease.addEventListener('click', () => {
            if (currentFontSize < 24) {
                currentFontSize += 1;
                readerContent.style.fontSize = currentFontSize + 'px';
                savePreferences();
            }
            if (evilModeActive === true) {
                readerContent.style.fontSize = '300px';
            }
        });
        fontFamily.addEventListener('change', () => {
            switch (fontFamily.value) {
                case 'sans':
                    readerContent.style.fontFamily = 'Arial, ui-sans-serif, system-ui, sans-serif';
                    break;
                case 'serif':
                    readerContent.style.fontFamily = 'Georgia, ui-serif, serif';
                    break;
                case 'mono':
                    readerContent.style.fontFamily = 'Courier New, ui-monospace, monospace';
                    break;
                case 'comic':
                    readerContent.style.fontFamily = 'Comic Sans MS, Comic Sans, cursive';
                    break;
                case 'times':
                    readerContent.style.fontFamily = 'Times New Roman, ui-serif, serif';
                    break;
                case 'verdana':
                    readerContent.style.fontFamily = 'Verdana, ui-sans-serif, system-ui, sans-serif';
                    break;
                case 'lex':
                    readerContent.style.fontFamily =
                        'OpenDyslexic, ui-sans-serif, system-ui, sans-serif';
                    break;
            }
            savePreferences();
        });
        spacingDecrease.addEventListener('click', () => {
            if (currentLineHeight > 1.2) {
                currentLineHeight -= 0.1;
                readerContent.style.lineHeight = currentLineHeight;
                savePreferences();
            }
        });
        spacingIncrease.addEventListener('click', () => {
            if (currentLineHeight < 2.5) {
                currentLineHeight += 0.1;
                readerContent.style.lineHeight = currentLineHeight;
                savePreferences();
            }
        });
        fontColorDropdown.addEventListener('change', function () {
            const selectedColor = this.value;
            switch (selectedColor) {
                case 'red':
                    readerContent.style.color = 'red';
                    break;
                case 'blue':
                    readerContent.style.color = 'blue';
                    break;
                case 'green':
                    readerContent.style.color = 'green';
                    break;
                case 'yellow':
                    readerContent.style.color = 'yellow';
                    break;
                case 'purple':
                    readerContent.style.color = 'purple';
                    break;
                default:
                    readerContent.style.color = '';
                    break;
            }
            savePreferences();
        });

        // ------------------------------
        // START FOCUS MODE IF ACTIVE
        // ------------------------------
        if (focusModeActive) {
            console.log("DEBUG: Page loaded and focus mode active. Starting focus mode.");
            startFocusMode();
        }

        // Annotation mode and highlight/eraser tools
        const highlightToggle = document.getElementById('highlight-toggle');
        const eraserToggle = document.getElementById('eraser-toggle');
        let activeTool = null;

        function setActiveTool(tool) {
            activeTool = tool;
            highlightToggle.classList.toggle('bg-primary-200', tool === 'highlight');
            eraserToggle.classList.toggle('bg-primary-200', tool === 'eraser');
            annotationToggle.classList.toggle('bg-primary-200', tool === 'annotation');
            document.body.style.cursor = tool === 'highlight' || tool === 'eraser' || tool === 'annotation' ?
                'text' : 'default';
        }

        highlightToggle.addEventListener('click', function () {
            setActiveTool('highlight');
        });

        eraserToggle.addEventListener('click', function () {
            setActiveTool('eraser');
        });

        annotationToggle.addEventListener('click', function () {
            setActiveTool('annotation');
        });

        document.addEventListener('mouseup', function () {
            const selectedText = window.getSelection().toString().trim();
            if (activeTool === 'highlight' && selectedText) {
                highlightText(selectedText);
                savePreferences();
            } else if (activeTool === 'eraser' && selectedText) {
                removeHighlight(selectedText);
                savePreferences();
            } else if (activeTool === 'annotation' && selectedText) {
                addAnnotation(selectedText);
                savePreferences();
            }
        });

// CREATE ANNOTATION
// Optional third parameter "existingId": if provided, we use it rather than generating a new one.
function addAnnotation(text, note = '', existingId) {
    console.log('Adding annotation for text:', text);

    // 1) Generate or re-use a unique ID for this annotation
    const annotationId = existingId || ('annotation-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5));

    // 2) Highlight the text in the article.
    // We only replace the first occurrence not already wrapped.
    const originalHTML = readerContent.innerHTML;
    const safeText = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // escape regex chars
    let replaced = false;
    const annotatedHTML = originalHTML.replace(new RegExp(safeText, 'gi'), function(match) {
        if (!replaced) {
            replaced = true;
            return `<span class="bg-blue-300 annotation" data-id="${annotationId}" data-text="${text}">${match}</span>`;
        }
        return match;
    });
    readerContent.innerHTML = annotatedHTML;

    // 3) Ensure the sidebar is visible and relatively positioned.
    const annotationPanel = document.getElementById('annotation-panel');
    annotationPanel.classList.remove('hidden');
    annotationPanel.style.position = 'relative';

    // 4) Create the annotation box in the sidebar.
    const annotationElement = document.createElement('div');
    annotationElement.className = 'annotation-box p-2 bg-white dark:bg-[#333] shadow rounded';
    annotationElement.style.position = 'absolute';
    // Store unique ID and text for later reference.
    annotationElement.dataset.id = annotationId;
    annotationElement.dataset.text = text;

    annotationElement.innerHTML = `
      <div class="font-bold text-sm text-primary-700 dark:text-primary-300 mb-1">
        Note:
      </div>
      <div class="bg-gray-200 dark:bg-gray-700 p-1 rounded-lg mb-2 text-sm">${text}</div>
      <textarea class="annotation-note w-full h-16 p-2 border border-gray-300 rounded-lg mb-2"
                placeholder="Please click edit to write" disabled>${note}</textarea>
      <div class="flex justify-end space-x-2">
        <button class="delete-annotation px-2 py-1 text-red-500 text-xs rounded-lg">
          <i class="fas fa-trash-alt"></i> Delete
        </button>
        <button class="edit-annotation px-2 py-1 text-blue-500 text-xs rounded-lg">
          <i class="fas fa-edit"></i> Edit
        </button>
        <button class="save-annotation px-2 py-1 text-green-500 text-xs rounded-lg hidden">
          <i class="fas fa-save"></i> Save
        </button>
      </div>
    `;
    annotationPanel.appendChild(annotationElement);

    // 5) Position the annotation box in the sidebar
    // Use the highlight span (found by its unique ID) to get the vertical offset.
    const highlightSpan = document.querySelector(`span.annotation[data-id="${annotationId}"]`);
    let offsetTop = 0;
    if (highlightSpan) {
        const highlightRect = highlightSpan.getBoundingClientRect();
        const panelRect = annotationPanel.getBoundingClientRect();
        offsetTop = (highlightRect.top + window.scrollY) - (panelRect.top + window.scrollY);
        if (offsetTop < 0) offsetTop = 0;
    }
    annotationElement.style.top = offsetTop + 'px';
    annotationElement.style.right = '0';

    // 6) Initialize the note textarea as read-only by default.
    const noteTextarea = annotationElement.querySelector('.annotation-note');
    noteTextarea.disabled = true;

    // 7) Wire up annotation actions.
    annotationElement.querySelector('.delete-annotation').addEventListener('click', function () {
        annotationElement.remove();
        removeAnnotation(annotationId);
        savePreferences();
        // If no annotations remain, hide the sidebar.
        if (annotationPanel.childElementCount === 0) {
            annotationPanel.classList.add('hidden');
        }
    });
    annotationElement.querySelector('.edit-annotation').addEventListener('click', function () {
        noteTextarea.disabled = false;
        noteTextarea.placeholder = 'Enter notes here';
        noteTextarea.focus();
        annotationElement.querySelector('.save-annotation').classList.remove('hidden');
        annotationElement.querySelector('.edit-annotation').classList.add('hidden');
    });
    annotationElement.querySelector('.save-annotation').addEventListener('click', function () {
        noteTextarea.disabled = true;
        noteTextarea.placeholder = 'Please click edit to write';
        annotationElement.querySelector('.save-annotation').classList.add('hidden');
        annotationElement.querySelector('.edit-annotation').classList.remove('hidden');
        savePreferences();
    });

    // 8) Scroll the annotation panel so the new annotation is in view.
    annotationElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    // 9) Persist changes (e.g., to localStorage).
    savePreferences();
}

// REMOVE ANNOTATION (by unique ID)
function removeAnnotation(annotationId) {
    const content = readerContent.innerHTML;
    const unannotatedContent = content.replace(
        /<span class="bg-blue-300 annotation" data-id="(.*?)" data-text="(.*?)">(.*?)<\/span>/gi,
        (match, p1, p2, p3) => p1 === annotationId ? p3 : match
    );
    readerContent.innerHTML = unannotatedContent;
}

// GET ALL ANNOTATIONS from the sidebar.
function getAnnotations() {
    const annotationBoxes = document.querySelectorAll('#annotation-panel .annotation-box');
    const annotations = [];
    annotationBoxes.forEach(box => {
        const text = box.dataset.text;
        const note = box.querySelector('.annotation-note').value;
        const id = box.dataset.id;
        annotations.push({ id, text, note });
    });
    return annotations;
}

// Load saved annotations on page load
if (articlePreferences.annotations) {
    articlePreferences.annotations.forEach(annotation => {
        addAnnotation(annotation.text, annotation.note, annotation.id);
    });
}

    });
    const colorBlindDropdown = document.getElementById('color-blind');

    colorBlindDropdown.addEventListener('change', function () {
        const selectedValue = this.value;
        // Get all images within the reader content container
        const images = document.querySelectorAll('#reader-content img');

        // Remove any previously applied filter classes from all images
        images.forEach(img => {
            img.classList.remove('deuteranomaly-filter', 'protanomaly-filter', 'deuteranopia-filter',
                'protanopia-filter');
        });

        // Apply the appropriate filter based on the user's selection
        if (selectedValue === 'deuteranomaly') {
            images.forEach(img => img.classList.add('deuteranomaly-filter'));
        } else if (selectedValue === 'protanomaly') {
            images.forEach(img => img.classList.add('protanomaly-filter'));
        } else if (selectedValue === 'deuteranopia') {
            images.forEach(img => img.classList.add('deuteranopia-filter'));
        } else if (selectedValue === 'protanopia') {
            images.forEach(img => img.classList.add('protanopia-filter'));
        }
        // If "default" is selected, no extra filter classes are applied.
    });
    document.addEventListener('DOMContentLoaded', function () {
        // Get button and container elements for each dropdown
        const btnFontColor = document.getElementById('toggle-font-color');
        const btnFontFamily = document.getElementById('toggle-font-family');
        const btnColorBlind = document.getElementById('toggle-color-blind');

        const containerFontColor = document.getElementById('dropdown-font-color');
        const containerFontFamily = document.getElementById('dropdown-font-family');
        const containerColorBlind = document.getElementById('dropdown-color-blind');

        // Toggle font color dropdown
        btnFontColor.addEventListener('click', function () {
            containerFontColor.classList.toggle('hidden');
        });

        // Toggle font family dropdown
        btnFontFamily.addEventListener('click', function () {
            containerFontFamily.classList.toggle('hidden');
        });

        // Toggle color blindness dropdown
        btnColorBlind.addEventListener('click', function () {
            containerColorBlind.classList.toggle('hidden');
        });
        // Close dropdowns when clicking outside
        document.addEventListener('click', function (event) {
            if (!containerFontColor.contains(event.target) && !btnFontColor.contains(event.target)) {
                containerFontColor.classList.add('hidden');
            }
            if (!containerFontFamily.contains(event.target) && !btnFontFamily.contains(event.target)) {
                containerFontFamily.classList.add('hidden');
            }
            if (!containerColorBlind.contains(event.target) && !btnColorBlind.contains(event.target)) {
                containerColorBlind.classList.add('hidden');
            }
        });

        document.getElementById('font-color').addEventListener('change', function () {
            containerFontColor.classList.add('hidden');
        });
        document.getElementById('font-family').addEventListener('change', function () {
            containerFontFamily.classList.add('hidden');
        });
        document.getElementById('color-blind').addEventListener('change', function () {
            containerColorBlind.classList.add('hidden');
        });
        const geminiGenerate = document.getElementById('gemini-generate');
const loadingScreen = document.getElementById('loading-screen');

geminiGenerate.addEventListener('click', function () {
    loadingScreen.style.display = 'flex';
    // Get all images from the reader content
    const images = document.querySelectorAll('#reader-content img');

    images.forEach(img => {
        // Avoid processing if a description already exists
        if (img.nextElementSibling && img.nextElementSibling.classList.contains('image-description')) {
            return;
        }
        const imageUrl = img.getAttribute('src');

        fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `You are an image captioning agent. For the image at URL: ${imageUrl}, please respond with an imageDescription(text) function call that includes a detailed description of the image. ONLY respond with the function call and nothing else.`
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log(data);
            if (data.success) {
                // Expecting a response like: imageDescription("A detailed description here")
                const match = data.response.match(/imageDescription\((.*?)\)/);
                if (match) {
                    const description = match[1].replace(/['"]/g, '');
                    const caption = document.createElement('div');
                    caption.className = 'image-description text-sm text-gray-600 dark:text-gray-300 mt-1';
                    caption.innerText = description;
                    img.parentNode.insertBefore(caption, img.nextSibling);
                }
            } else {
                showToast('Error: ' + data.error);
            }
        })
        .catch(error => {
            showToast('Error: ' + error.message);
        })
        .finally(() => {
            loadingScreen.style.display = 'none';
        });
    });
});

    });

    document.addEventListener('DOMContentLoaded', function () {
        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;

        // Check for saved theme preference or use system preference
        const savedTheme = BookWormCookies.cookiesAccepted() ? 
            BookWormCookies.getCookie('bookworm_theme') : null;
        
        if (savedTheme === 'dark' || 
            (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            body.classList.add('dark');
        } else {
            body.classList.remove('dark');
        }

        themeToggle.addEventListener('click', () => {
            const isDark = body.classList.toggle('dark');
            updateBackgroundImage(isDark);

            if (BookWormCookies.cookiesAccepted()) {
                BookWormCookies.setCookie('bookworm_theme', isDark ? 'dark' : 'light', 365);
            }
        });

        function updateBackgroundImage(isDarkMode) {
            const gardenElement = document.querySelector('.h-64.w-full');
            if (isDarkMode) {
                gardenElement.classList.add('bg-night-mode');
                gardenElement.classList.remove('bg-day-mode');
            } else {
                gardenElement.classList.add('bg-day-mode');
                gardenElement.classList.remove('bg-night-mode');
            }
        }
    });
</script>
{% endblock %}