{% extends 'base.html' %}

{% block title %}{{ title }} | BookWorm Reader{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto bg-white dark:bg-[#222222] rounded-lg shadow-lg mb-12 overflow-hidden">
    <!-- Reader Content as iframe-like container -->
    <div id="reader-container" class="docs-container">
        <div id="reader-content" class="docs-content">
            {{ content|safe }}
        </div>
    </div>

    <!-- Cookie consent bar -->
    <div id="cookie-consent"
         class="fixed bottom-0 left-0 w-full bg-primary-100 dark:bg-primary-800 p-4 flex justify-between items-center shadow-lg z-50 hidden">
        <div class="text-sm">
            We use cookies to save your Focus Garden progress. This helps your plants grow across reading sessions.
        </div>
        <div class="flex space-x-2">
            <button id="deny-cookies"
                    class="px-3 py-1 bg-white dark:bg-gray-700 text-primary-800 dark:text-primary-200 rounded text-sm">
                No thanks
            </button>
            <button id="accept-cookies"
                    class="px-3 py-1 bg-accent-600 dark:bg-accent-500 text-white rounded text-sm">
                Accept
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block footer %}
<!-- Focus Mode Garden (moved to footer) -->
<footer class="mt-12 pt-6">
    <div id="focus-garden">
        <h3 class="text-center text-lg font-medium mb-4 text-accent-600 dark:text-accent-400">
            <i class="fas fa-seedling mr-2"></i>Your Focus Garden
        </h3>
        <div class="flex justify-between items-center mt-2 text-sm">
            <div>
                <span id="focus-time">0</span> minutes of distraction-free reading
            </div>
            <div class="text-right">
                <span class="text-red-500 hidden" id="focus-draining">‚ö†Ô∏è Focus draining...</span>
            </div>
        </div>
        <div class="mt-2 w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
            <div id="focus-progress" class="bg-accent-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
        <div class="h-32 bg-[#f5f5f0] dark:bg-[#252520] rounded-lg overflow-hidden relative">
            <div class="flex justify-center items-end h-full">
                <!-- Placeholder for garden elements that will be added with JS -->
                <div id="garden-elements" class="flex space-x-2 mb-2"></div>
            </div>
            <div class="absolute bottom-0 left-0 right-0 h-4 bg-accent-800 dark:bg-accent-900 opacity-30"></div>
        </div>
    </div>
</footer>
{% endblock %}

{% block head %}
<style>
    /* Google Docs like styling */
    .docs-container {
        background-color: #F9F9F9;
        padding: 0;
        min-height: 70vh;
        overflow-y: auto;
        border: 1px solid #E0E0E0;
    }
    .dark .docs-container {
        background-color: #2D2D2D;
        border-color: #444444;
    }
    .docs-content {
        background-color: white;
        max-width: 850px;
        margin: 40px auto;
        padding: 60px;
        min-height: 1100px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        font-family: 'Arial', sans-serif;
        color: #333;
        line-height: 1.6;
        font-size: 14px;
    }
    .dark .docs-content {
        background-color: #333333;
        color: #E0E0E0;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .docs-content h1, .docs-content h2, .docs-content h3 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        font-weight: 400;
    }
    .docs-content h1 {
        font-size: 2em;
    }
    .docs-content h2 {
        font-size: 1.5em;
    }
    .docs-content p {
        margin-bottom: 1em;
    }
    .docs-content a {
        color: #1a73e8;
        text-decoration: none;
    }
    .dark .docs-content a {
        color: #8ab4f8;
    }
    .docs-content img {
        max-width: 100%;
        height: auto;
        margin: 1em 0;
    }
    /* Garden plant animations */
    @keyframes growPlant {
        0% { transform: scale(0.5); opacity: 0.5; }
        100% { transform: scale(1); opacity: 1; }
    }
    .garden-plant {
        animation: growPlant 1s ease-out forwards;
    }
    /* Focus draining animation */
    @keyframes pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
    }
    #focus-draining {
        animation: pulse 2s infinite;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // ------------------------------
    // ELEMENT REFERENCES & INITIAL STATE
    // ------------------------------
    const originalTitle = document.title;
    const readerContent = document.getElementById('reader-content');
    const fontDecrease = document.getElementById('font-decrease');
    const fontIncrease = document.getElementById('font-increase');
    const fontFamily = document.getElementById('font-family');
    const spacingDecrease = document.getElementById('spacing-decrease');
    const spacingIncrease = document.getElementById('spacing-increase');
    const annotationMode = document.getElementById('annotation-mode');
    const readAloud = document.getElementById('read-aloud');
    const cookieConsent = document.getElementById('cookie-consent');
    const acceptCookies = document.getElementById('accept-cookies');
    const denyCookies = document.getElementById('deny-cookies');
    const focusDraining = document.getElementById('focus-draining');
    const focusProgress = document.getElementById('focus-progress');
    const focusTimeDisplay = document.getElementById('focus-time');
    const gardenElements = document.getElementById('garden-elements');
    const fontColorDropdown = document.getElementById('font-color');

    let evilModeActive = false;
    let currentFontSize = parseInt(window.getComputedStyle(readerContent).fontSize);
    let currentLineHeight = 1.6;
    let isAnnotationMode = false;
    let isReading = false;
    let speechUtterance = null;
    let cookiesAccepted = false;

    // Focus mode variables
    let focusModeActive = true; // Set true to start focus mode automatically
    let focusMinutes = 0;
    let focusTimer = null;
    let drainTimer = null;
    let elapsedSeconds = 0; // Track seconds within the current minute
    const evilModeToggle = document.getElementById('evil-mode-toggle');
    const COOKIE_CONSENT_NAME = 'bookworm_cookie_consent';
    const FOCUS_MINUTES_NAME = 'bookworm_focus_minutes';
    const GARDEN_PLANTS_NAME = 'bookworm_garden_plants';
    const PLANTS_PER_MINUTE = 1; // 1 plant per minute

    // Toolbar modifications for evil mode
    const toolbarButtons = document.querySelectorAll(
        '#font-decrease, #font-increase, #read-aloud, #spacing-decrease, #spacing-increase, #highlight-toggle, #eraser-toggle, #chat-toggle, #magic-highlight'
    );
    const originalToolbarHTML = {};
    toolbarButtons.forEach(btn => {
        originalToolbarHTML[btn.id] = btn.innerHTML;
    });
    const fontFamilySelect = document.getElementById('font-family');
    const originalFontFamilyOptions = fontFamilySelect ? fontFamilySelect.innerHTML : '';

    // ------------------------------
    // HELPER FUNCTIONS
    // ------------------------------
    // Reverse a string (for evil read-aloud)
    function reverseText(text) {
        return text.split('').reverse().join('');
    }

    // ------------------------------
    // COOKIE FUNCTIONS & DATA LOADING
    // ------------------------------
    function checkCookieConsent() {
        const consent = getCookie(COOKIE_CONSENT_NAME);
        if (consent === 'accepted') {
            cookiesAccepted = true;
        } else {
            cookieConsent.classList.remove('hidden');
        }
    }
    function setCookie(name, value, days) {
        if (!cookiesAccepted && name !== COOKIE_CONSENT_NAME) return;
        let expires = '';
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = '; expires=' + date.toUTCString();
        }
        document.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/';
    }
    function getCookie(name) {
        const nameEQ = name + '=';
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i].trim();
            if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length));
        }
        return null;
    }
    function loadFocusData() {
        const savedMinutes = getCookie(FOCUS_MINUTES_NAME);
        if (savedMinutes) {
            focusMinutes = parseInt(savedMinutes);
            focusTimeDisplay.textContent = focusMinutes;
            updateProgressBar(0);
        }
        const savedPlants = getCookie(GARDEN_PLANTS_NAME);
        if (savedPlants) {
            try {
                const plants = JSON.parse(savedPlants);
                plants.forEach(plant => {
                    addGardenElement(plant.icon, plant.height, plant.color);
                });
            } catch (e) {
                console.error('Failed to parse garden plants cookie', e);
            }
        }
    }
    function saveFocusData() {
        if (cookiesAccepted) {
            setCookie(FOCUS_MINUTES_NAME, focusMinutes.toString(), 365);
            const plants = [];
            document.querySelectorAll('.garden-plant').forEach(plant => {
                const icon = plant.querySelector('i').className;
                const height = plant.querySelector('i').style.fontSize;
                const match = icon.match(/text-[a-z]+-\d+/);
                const colorClass = match ? match[0] : '';
                plants.push({ icon, height, color: colorClass });
            });
            setCookie(GARDEN_PLANTS_NAME, JSON.stringify(plants), 365);
        }
    }
    checkCookieConsent();
    if (cookiesAccepted) {
        loadFocusData();
    }

    // ------------------------------
    // EVIL MODE TOGGLE & MODIFICATIONS
    // ------------------------------
    evilModeToggle.addEventListener('click', function() {
        evilModeActive = !evilModeActive;
        if (evilModeActive) {
            activateEvilMode();
        } else {
            deactivateEvilMode();
        }
    });
    
    function activateEvilMode() {
        // Replace toolbar buttons' content with an evil emoji
        toolbarButtons.forEach(btn => {
            const evilEmojis = ['üòà', 'üëπ', 'üë∫', 'üíÄ', 'üëª', 'üëΩ', 'ü§ñ', 'üëæ'];
            const randomEmoji = evilEmojis[Math.floor(Math.random() * evilEmojis.length)];
            btn.innerHTML = randomEmoji;
        });
        // Change the font-family dropdown to evil choices
        if (fontFamilySelect) {
            fontFamilySelect.innerHTML = `<option value="wingdings">Wingdings</option>`;
        }
        // Change the reader content to use a less readable font (e.g. Wingdings)
        if (readerContent) {
            readerContent.style.fontFamily = 'Wingdings, sans-serif';
        }
        // Additional evil modifications can be added here
    }
    
    function deactivateEvilMode() {
        // Restore original toolbar buttons
        toolbarButtons.forEach(btn => {
            if (originalToolbarHTML[btn.id]) {
                btn.innerHTML = originalToolbarHTML[btn.id];
            }
        });
        // Restore original font-family dropdown options
        if (fontFamilySelect) {
            fontFamilySelect.innerHTML = originalFontFamilyOptions;
        }
        // Restore the reader content font
        if (readerContent) {
            readerContent.style.fontFamily = '';
        }
        // Additional restoration code can be added here
    }

    // ------------------------------
    // FOCUS MODE FUNCTIONS
    // ------------------------------
    function startFocusMode() {
        console.log("DEBUG: Starting focus mode, current focus minutes:", focusMinutes);
        elapsedSeconds = 0;
        focusTimer = setInterval(() => {
            elapsedSeconds++;
            updateProgressBar(elapsedSeconds);
            if (elapsedSeconds >= 60) {
                focusMinutes++;
                elapsedSeconds = 0;
                focusTimeDisplay.textContent = focusMinutes;
                console.log("DEBUG: Focus minute incremented to:", focusMinutes);
                addRandomGardenElement();
                saveFocusData();
            }
        }, 1000);
        const expectedPlants = Math.floor(focusMinutes * PLANTS_PER_MINUTE);
        const currentPlants = document.querySelectorAll('.garden-plant').length;
        if (currentPlants < expectedPlants) {
            addRandomGardenElement();
        }
    }
    function updateProgressBar(seconds) {
        const progress = (seconds / 60) * 100;
        focusProgress.style.width = `${progress}%`;
    }
    function addRandomGardenElement() {
        console.log("DEBUG: Adding random garden element.");
        const plantTypes = [
            { icon: 'fa-seedling', height: '30px', color: 'text-accent-500' },
            { icon: 'fa-leaf', height: '40px', color: 'text-accent-600' },
            { icon: 'fa-tree', height: '50px', color: 'text-accent-700' },
            { icon: 'fa-pagelines', height: '45px', color: 'text-accent-500' }
        ];
        const randomPlant = plantTypes[Math.floor(Math.random() * plantTypes.length)];
        addGardenElement(randomPlant.icon, randomPlant.height, randomPlant.color);
    }
    function addGardenElement(icon, height, color) {
        console.log("DEBUG: Adding garden element with icon:", icon, "height:", height, "color:", color);
        const element = document.createElement('div');
        element.className = 'garden-plant';
        element.style.position = 'absolute';
        const containerBox = gardenElements.closest('.relative');
        if (containerBox) {
            const containerWidth = containerBox.offsetWidth;
            const containerHeight = containerBox.offsetHeight;
            const randomTop = containerHeight - 60;
            let randomLeft;
            let overlap;
            do {
                randomLeft = Math.random() * (containerWidth - 40);
                overlap = Array.from(gardenElements.children).some(existingElement => {
                    const existingRect = existingElement.getBoundingClientRect();
                    const newRect = {
                        left: randomLeft,
                        top: randomTop,
                        right: randomLeft + 40,
                        bottom: randomTop + 40
                    };
                    return !(newRect.right < existingRect.left ||
                             newRect.left > existingRect.right ||
                             newRect.bottom < existingRect.top ||
                             newRect.top > existingRect.bottom);
                });
            } while (overlap);
            element.style.left = randomLeft + 'px';
            element.style.top = randomTop + 'px';
            console.log("DEBUG: Plant positioned at:", randomLeft, randomTop);
        }
        element.innerHTML = `<i class="fas ${icon} ${color}" style="font-size: ${height}"></i>`;
        gardenElements.appendChild(element);
    }
    function startFocusDraining() {
        console.log("DEBUG: Starting focus draining.");
        clearInterval(focusTimer);
        focusTimer = null;
        focusDraining.classList.remove('hidden');
        document.title = '‚ö†Ô∏è Focus Draining';
        drainTimer = setInterval(() => {
            console.log("DEBUG: Draining focus minute. Current focus minutes:", focusMinutes);
            if (focusMinutes > 0) {
                focusMinutes--;
                focusTimeDisplay.textContent = focusMinutes;
                updateProgressBar(0);
                saveFocusData();
                if (gardenElements.children.length > 0) {
                    console.log("DEBUG: Removing a garden element due to focus drain.");
                    gardenElements.removeChild(gardenElements.lastChild);
                }
            }
        }, 30000);
    }
    function stopFocusDraining() {
        console.log("DEBUG: Stopping focus draining.");
        clearInterval(drainTimer);
        drainTimer = null;
        focusDraining.classList.add('hidden');
        document.title = originalTitle;
    }
    document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
            if (focusModeActive) {
                startFocusDraining();
            }
        } else {
            stopFocusDraining();
            if (focusModeActive && !focusTimer) {
                startFocusMode();
            }
        }
    });

    // ------------------------------
    // OTHER FUNCTIONALITY (Read Aloud, Font/Spacing, Annotation)
    // ------------------------------
    readAloud.addEventListener('click', () => {
        if (!isReading) {
            isReading = true;
            readAloud.classList.add('bg-accent-200', 'dark:bg-accent-800');
            const originalText = readerContent.innerText;
            // If evil mode is active, reverse the text before speaking and lower the pitch
            const textToSpeak = evilModeActive ? reverseText(originalText) : originalText;
            speechUtterance = new SpeechSynthesisUtterance(textToSpeak);
            if (evilModeActive) {
            speechUtterance.pitch = 0.1; // Lower the pitch for evil mode
            speechUtterance.rate = 1.2; // Increase the rate for evil mode

    function setActiveTool(tool) {
        activeTool = tool;
        highlightToggle.classList.toggle('bg-primary-200', tool === 'highlight');
        eraserToggle.classList.toggle('bg-primary-200', tool === 'eraser');
        document.body.style.cursor = tool === 'highlight' || tool === 'eraser' ? 'text' : 'default';
    }

    window.highlightText = function(text) {
        const content = readerContent.innerHTML;
        const highlightedContent = content.replace(new RegExp(text, 'gi'), match => `<span class="bg-yellow-300">${match}</span>`);
        readerContent.innerHTML = highlightedContent;
    }

    window.removeHighlight = function(text) {
        const content = readerContent.innerHTML;
        const unhighlightedContent = content.replace(/<span class="bg-yellow-300">(.*?)<\/span>/gi, (match, p1) => {
            return p1.includes(text) ? p1 : match;
        });
        readerContent.innerHTML = unhighlightedContent;
    }

    const magicHighlight = document.getElementById('magic-highlight');
    const loadingScreen = document.getElementById('loading-screen');

    magicHighlight.addEventListener('click', function() {
        loadingScreen.style.display = 'flex';
        const content = document.getElementById('reader-content').innerText;

        fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `You are a text summarization agent, which has the capability to highlight important aspects or key points of an article below. For all of the text in the article, please respond with a highlight(text) function, stating the exact text that you want highlighted. Separate these functions by semicolons, and ONLY respond with the function calls and nothing else. Feel free to highlight more often, as this will help the user. Make the text to highlight EXACTLY what is listed in the article, otherwise the system will not highlight for you. Here is the article: ${content}`
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log(data);
            if (data.success) {
            const highlights = data.response.match(/highlight\((.*?)\);/g);
            if (highlights) {
                highlights.forEach(call => {
                const textToHighlight = call.match(/highlight\((.*?)\);/)[1];
                highlightText(textToHighlight.replace(/['"]/g, ''));
                });
            }
            } else {
            showToast('Error: ' + data.error);
            }
            speechUtterance.onend = () => {
            isReading = false;
            readAloud.classList.remove('bg-accent-200', 'dark:bg-accent-800');
            };
            speechSynthesis.speak(speechUtterance);
        } else {
            isReading = false;
            readAloud.classList.remove('bg-accent-200', 'dark:bg-accent-800');
            speechSynthesis.cancel();
        }
    });

    fontDecrease.addEventListener('click', () => {
        if (currentFontSize > 12) {
            currentFontSize -= 1;
            readerContent.style.fontSize = currentFontSize + 'px';
            savePreferences();
        }
        if (evilModeActive === true) {
            readerContent.style.fontSize = '1px';
        }
    });
    fontIncrease.addEventListener('click', () => {
        if (currentFontSize < 24) {
            currentFontSize += 1;
            readerContent.style.fontSize = currentFontSize + 'px';
            savePreferences();
        }
        if (evilModeActive === true) {
            readerContent.style.fontSize = '300px';
        }
    });
    fontFamily.addEventListener('change', () => {
        switch(fontFamily.value) {
            case 'sans':
                readerContent.style.fontFamily = 'Arial, ui-sans-serif, system-ui, sans-serif';
                break;
            case 'serif':
                readerContent.style.fontFamily = 'Georgia, ui-serif, serif';
                break;
            case 'mono':
                readerContent.style.fontFamily = 'Courier New, ui-monospace, monospace';
                break;
            case 'comic':
                readerContent.style.fontFamily = 'Comic Sans MS, Comic Sans, cursive';
                break;
            case 'times':
                readerContent.style.fontFamily = 'Times New Roman, ui-serif, serif';
                break;
            case 'verdana':
                readerContent.style.fontFamily = 'Verdana, ui-sans-serif, system-ui, sans-serif';
                break;
            case 'lex':
                readerContent.style.fontFamily = 'OpenDyslexic, ui-sans-serif, system-ui, sans-serif';
                break;
        }
        savePreferences();
    });
    spacingDecrease.addEventListener('click', () => {
        if (currentLineHeight > 1.2) {
            currentLineHeight -= 0.1;
            readerContent.style.lineHeight = currentLineHeight;
            savePreferences();
        }
    });
    spacingIncrease.addEventListener('click', () => {
        if (currentLineHeight < 2.5) {
            currentLineHeight += 0.1;
            readerContent.style.lineHeight = currentLineHeight;
            savePreferences();
        }
    });
    fontColorDropdown.addEventListener('change', function() {
        const selectedColor = this.value;
        switch(selectedColor) {
            case 'red':
                readerContent.style.color = 'red';
                break;
            case 'blue':
                readerContent.style.color = 'blue';
                break;
            case 'green':
                readerContent.style.color = 'green';
                break;
            case 'yellow':
                readerContent.style.color = 'yellow';
                break;
            case 'purple':
                readerContent.style.color = 'purple';
                break;
            default:
                readerContent.style.color = '';
                break;
        }
        savePreferences();
    });

    // Annotation mode and highlight/eraser tools
    const highlightToggle = document.getElementById('highlight-toggle');
    const eraserToggle = document.getElementById('eraser-toggle');
    let activeTool = null;
    highlightToggle.addEventListener('click', function() {
        setActiveTool('highlight');
    });
    eraserToggle.addEventListener('click', function() {
        setActiveTool('eraser');
    });
    document.addEventListener('mouseup', function() {
        const selectedText = window.getSelection().toString().trim();
        if (activeTool === 'highlight' && selectedText) {
            highlightText(selectedText);
        } else if (activeTool === 'eraser' && selectedText) {
            removeHighlight(selectedText);
        }
    });
    function setActiveTool(tool) {
        activeTool = tool;
        highlightToggle.classList.toggle('bg-primary-200', tool === 'highlight');
        eraserToggle.classList.toggle('bg-primary-200', tool === 'eraser');
        document.body.style.cursor = (tool === 'highlight' || tool === 'eraser') ? 'text' : 'default';
    }
    window.highlightText = function(text) {
        const content = readerContent.innerHTML;
        const highlightedContent = content.replace(new RegExp(text, 'gi'), match => `<span class="bg-yellow-300">${match}</span>`);
        readerContent.innerHTML = highlightedContent;
        savePreferences();
    }
    window.removeHighlight = function(text) {
        const content = readerContent.innerHTML;
        const unhighlightedContent = content.replace(/<span class="bg-yellow-300">(.*?)<\/span>/gi, (match, p1) => {
            return p1.includes(text) ? p1 : match;
        });
        readerContent.innerHTML = unhighlightedContent;
        savePreferences();
    };
    }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const readerContent = document.getElementById('reader-content');
    const fontDecrease = document.getElementById('font-decrease');
    const fontIncrease = document.getElementById('font-increase');
    const fontFamily = document.getElementById('font-family');
    const fontColorDropdown = document.getElementById('font-color');
    const spacingDecrease = document.getElementById('spacing-decrease');
    const spacingIncrease = document.getElementById('spacing-increase');
    const highlightToggle = document.getElementById('highlight-toggle');
    const eraserToggle = document.getElementById('eraser-toggle');
    const annotationToggle = document.getElementById('annotation-toggle');
    let activeTool = null;
    const url = '{{ url }}';

    function getAnnotations() {
        const annotations = [];
        document.querySelectorAll('.annotation').forEach(annotation => {
            annotations.push({
                text: annotation.dataset.text,
                note: annotation.querySelector('.annotation-note').value
            });
        });
        return annotations;
    }
  
    // ------------------------------
    // START FOCUS MODE IF ACTIVE
    // ------------------------------
    if (focusModeActive) {
        console.log("DEBUG: Page loaded and focus mode active. Starting focus mode.");
        startFocusMode();

    highlightToggle.addEventListener('click', function() {
        setActiveTool('highlight');
    });

    eraserToggle.addEventListener('click', function() {
        setActiveTool('eraser');
    });

    annotationToggle.addEventListener('click', function() {
        setActiveTool('annotation');
    });

    document.addEventListener('mouseup', function() {
        const selectedText = window.getSelection().toString().trim();
        if (activeTool === 'highlight' && selectedText) {
            highlightText(selectedText);
            savePreferences();
        } else if (activeTool === 'eraser' && selectedText) {
            removeHighlight(selectedText);
            savePreferences();
        } else if (activeTool === 'annotation' && selectedText) {
            addAnnotation(selectedText);
            savePreferences();
        }
    });

    function setActiveTool(tool) {
        activeTool = tool;
        highlightToggle.classList.toggle('bg-primary-200', tool === 'highlight');
        eraserToggle.classList.toggle('bg-primary-200', tool === 'eraser');
        annotationToggle.classList.toggle('bg-primary-200', tool === 'annotation');
        document.body.style.cursor = tool === 'highlight' || tool === 'eraser' || tool === 'annotation' ? 'text' : 'default';
    }

    window.highlightText = function(text) {
        console.log('Highlighting text:', text);
        const content = readerContent.innerHTML;
        const highlightedContent = content.replace(new RegExp(text, 'gi'), match => `<span class="bg-yellow-300">${match}</span>`);
        readerContent.innerHTML = highlightedContent;
        savePreferences();
    }

    window.removeHighlight = function(text) {
        console.log('Removing highlight for text:', text);
        const content = readerContent.innerHTML;
        const unhighlightedContent = content.replace(/<span class="bg-yellow-300">(.*?)<\/span>/gi, (match, p1) => {
            return p1.includes(text) ? p1 : match;
        });
        readerContent.innerHTML = unhighlightedContent;
        savePreferences();
    }

    function addAnnotation(text, note = '') {
        console.log('Adding annotation for text:', text);
        const content = readerContent.innerHTML;
        const annotatedContent = content.replace(new RegExp(text, 'gi'), match => `<span class="bg-blue-300 annotation" data-text="${text}">${match}</span>`);
        readerContent.innerHTML = annotatedContent;
        const annotationElement = document.createElement('div');
        annotationElement.className = 'annotation-box';
        annotationElement.innerHTML = `
            <textarea class="annotation-note">${note}</textarea>
            <button class="delete-annotation">Delete</button>
            <button class="edit-annotation">Edit</button>
            <button class="save-annotation">Save</button>
        `;
        document.body.appendChild(annotationElement);
        annotationElement.querySelector('.delete-annotation').addEventListener('click', function() {
            annotationElement.remove();
            removeAnnotation(text);
            savePreferences();
        });
        annotationElement.querySelector('.edit-annotation').addEventListener('click', function() {
            annotationElement.querySelector('.annotation-note').disabled = false;
        });
        annotationElement.querySelector('.save-annotation').addEventListener('click', function() {
            annotationElement.querySelector('.annotation-note').disabled = true;
            savePreferences();
        });
        savePreferences();
    }

    function removeAnnotation(text) {
        const content = readerContent.innerHTML;
        const unannotatedContent = content.replace(/<span class="bg-blue-300 annotation" data-text="(.*?)">(.*?)<\/span>/gi, (match, p1, p2) => {
            return p1.includes(text) ? p2 : match;
        });
        readerContent.innerHTML = unannotatedContent;
    }
});
</script>
{% endblock %}
